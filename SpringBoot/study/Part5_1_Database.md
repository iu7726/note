# 스프링 데이터 베이스 접근 기술

 - H2 데이터베이스 설치
 - 순수 Jdbc
 - 스프링 JdbcTemplate
 - JPA
 - 스프링 데이터 JPA

## H2 데이터베이스 설치

http://www.h2database.com/html/main.html

접속하여 설치파일을 다운로드 받아주세요.

`h2-setup-2019-10-14.exe`을 실행시켜 설치를 진행해주세요.

`H2 Console`을 실행시켜주세요.

<img src="../../iamges/H2 Setting.png">

교육용이니 별다른 설정은 하지않고 진행하겠습니다.

<b>연결</b>버튼을 클릭합니다.

<img src="../../iamges/H2_console_main.png">

접속 성공한 화면입니다.

JDBC URL을 보시면 `jdbc:h2:~/test`라고 설정이 되어있는데 현재는 파일로 접근을 하는 상태입니다.

이렇게 되면 어플리케이션과 콘솔이 동시에 한 파일로 접속을 하기 때문에 접속 오류가 생길 가능성이 있습니다.

`jdbc:h2:tcp://localhost/~/test`으로 수정합니다.

파일을 통해 접근하는 것이 아닌 소켓을 통해 접근합니다.

### 테이블 생성

```sql
drop table if exists member CASCADE;
create table member
(
 id bigint generated by default as identity,
 name varchar(255),
 primary key (id)
);
```

member 테이블을 생성합니다.
 - id pk 및 auto increment 설정
 - name varchar 255 설정


```sql
INSERT INTO MEMBER(name) VALUES ('spring');
INSERT INTO MEMBER(name) VALUES ('spring2');
```

초기 데이터를 세팅합니다.

<img src="../../iamges/H2_insert_result.png">

결화 화면입니다.

### sql history

테이블을 수정하거나 생성하면 언제 누가 생성했는지 관리가 안될떄가 있습니다.

따로 프로그램을 써서 공유를 한다면 모르겠지만 그렇지 않는 경우에 DB가 바뀐것을 인지하지 못한 다른 작업자가 작업을 진행할 때 오류가 발생하고 해당 작업자는 엄청난 삽질을 시작합니다.

이러한 삽질을 방지하기 위해 간단한 파일을 하나 생성하여 history 추적을 합니다.

`\sql\sql_history.sql`

```sql
# MEMBER 테이블 생성
drop table if exists member CASCADE;
create table member
(
 id bigint generated by default as identity,
 name varchar(255),
 primary key (id)
);
```

이런식으로 변경 또는 생성된 테이블이 있다면 기록을 남기겠습니다.

이렇게 관리를 하면 git에 push를 넣을 때 마다 자동으로 같이 포함이 되어 올라가기 때문에 언제 누가 어떻게 테이블을 수정, 생성했는지 알 수 있습니다.

## 순수 Jdbc

현재는 순수 Jdbc를 이용한 개발을 많이 진행하지는 않습니다.

처음에는 이렇게 사용했다 정도로만 봐주세요.

`build.gradle`의 `dependencies`에 `jdbc`,`h2` 데이터베이스 관련 라이브러리를 추가합니다.

```gradle
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'org.springframework.boot:spring-boot-starter-jdbc'
	runtimeOnly 'com.h2database:h2'
	testImplementation('org.springframework.boot:spring-boot-starter-test') {
		exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
	}
}
```

Java는 DB에 접속할 때 Jdbc 라이브러리가 필수입니다.

`com.h2database:h2` : 데이터베이스에 접속할 클라이언트입니다.

<img src="../../iamges/gradle_import.png" />

import 버튼을 클릭해 해당 패키지를 import해주세요.

### spring.properties 설정

`\src\main\resources\application.properties`

```properties
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.driver-class-name=org.h2.Driver
```

여기까지가 데이터베이스를 이용하기위한 준비입니다.

### 사용해보기

```java
package hello.myspring.repository;

import hello.myspring.domain.Member;

import org.springframework.jdbc.datasource.DataSourceUtils;
import javax.sql.DataSource;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

public class JdbcMemberRepository implements MemberRepository {
    private final DataSource dataSource;

    public JdbcMemberRepository(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Override
    public Member save(Member member) {
        //sql 생성
        String sql = "insert into member(name) values(?)";

        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;

        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            pstmt.setString(1, member.getName()); // ?랑 매칭합니다.
            pstmt.executeUpdate(); // query 실행
            rs = pstmt.getGeneratedKeys(); // insert된 id값을 가져옵니다.Statement.RETURN_GENERATED_KEYS랑 매칭됩니다.
            if (rs.next()) {
                member.setId(rs.getLong(1));
            } else {
                throw new SQLException("id 조회 실패");
            }
            return member;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs); // 소켓 파괴 (리소스 반환)
        }
    }

    @Override
    public Optional<Member> findById(Long id) {
        String sql = "select * from member where id = ?";

        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;

        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            pstmt.setLong(1, id);

            rs = pstmt.executeQuery();

            if(rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                return Optional.of(member);
            } else {
                return Optional.empty();
            }
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }

    @Override
    public List<Member> findAll() {

        String sql = "select * from member";

        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;

        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);

            rs = pstmt.executeQuery();

            List<Member> members = new ArrayList<>();
            while(rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                members.add(member);
            }
            return members;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }

    @Override
    public Optional<Member> findByName(String name) {
        String sql = "select * from member where name = ?";

        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;

        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            pstmt.setString(1, name);

            rs = pstmt.executeQuery();

            if(rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                return Optional.of(member);
            }
            return Optional.empty();
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }

    private Connection getConnection() {
        return DataSourceUtils.getConnection(dataSource); //spring을 통해 connection을 얻습니다.
    }

    private void close(Connection conn, PreparedStatement pstmt, ResultSet rs)
    {
        try {
            if (rs != null) {
                rs.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            if (pstmt != null) {
                pstmt.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            if (conn != null) {
                close(conn);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private void close(Connection conn) throws SQLException {
        DataSourceUtils.releaseConnection(conn, dataSource); //spring을 통해 connection을 종료합니다.
    }
}
```

`SpringConfig`를 수정합니다.

```java
package hello.myspring;

import hello.myspring.repository.JdbcMemberRepository;
import hello.myspring.repository.MemberRepository;
import hello.myspring.service.MemberService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.sql.DataSource;

@Configuration
public class SpringConfig {

    private DataSource dataSource;

    @Autowired
    public SpringConfig(DataSource dataSource){
        this.dataSource = dataSource;
    }

    @Bean
    public MemberService memberService(){
        return new MemberService(memoryMemberRepository());
    }

    @Bean
    public MemberRepository memoryMemberRepository(){
        //return new MemoryMemberRepository();
        return new JdbcMemberRepository(this.dataSource);
    }
}
```

<img src="../../iamges/plain_jdbc_ret.png"/>

DB CR이 정상적으로 실행되는 모습을 확인하실수 있습니다.

이렇게 인터페이스의 구현체를 바꾸는 것만으로도 메모리에서 DB로 변경이 되었습니다.

이런 다형성 때문에 Spring을 사용하는 이유도 있습니다.

<img src="../../iamges/DB_class_flow.png" />

<img src="../../iamges/DB_spring_flow.png" />

 - 개방 폐쇄 원칙(OCP, Open_Closed Principle)
   - 확장에는 열려있고 수정에는 닫혀있습니다.
 - 스프링의 DI를 사용하면 <b>기존 코드를 전혀 손대지 않고(web application), 설정만으로 구현 클래스를 변경</b>이 가능합니다.
 - 이제 DB에 저장하므로 서버 메모리와 다르게 서버를 내렸다가 다시 올려도 데이터가 남아있습니다.

### 스프링 통합 테스트

DB를 연결했으니 DB작동까지 테스트를 진행합니다.

이전에 테스트했던 코드는 순수하게 Java코드만 이용해서 테스트를 진행했습니다.

하지만 DB가 붙은 이후에 테스트를 진행하려면 DB connection 등의 추가 패키지가 필요합니다.

> 테스트를 진행할 때는 모두 구현이 된 상태에서 진행하기 때문에 필드 autowired를 받아도 무방합니다.

Test Code

```java
package hello.myspring.service;

import hello.myspring.domain.Member;
import hello.myspring.repository.MemberRepository;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.transaction.annotation.Transactional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

@SpringBootTest
@Transactional
class MemberServiceIntegrationTest {

    @Autowired MemberService memberService;
    @Autowired MemberRepository memoryMemberRepository;

    @Test
    void join() {
        //given
        Member member = new Member();
        member.setName("hello");

        //when
        Long saveId = memberService.join(member);

        //then
        Member findMember = memberService.findOne(saveId).get();
        assertThat(member.getName()).isEqualTo(findMember.getName());
    }

    @Test
    void 중복_회원_예외(){
        //given
        Member member1 = new Member();
        member1.setName("springTest1");

        Member member2 = new Member();
        member2.setName("springTest2");

        //when
        memberService.join(member1);

        IllegalStateException e = assertThrows(IllegalStateException.class, () -> memberService.join(member2));

        assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다.");

    }
}
```
 - @spring : 스프링 컨테이너와 테스트를 함께 실행합니다.
 - @Transactional : DB commit 전에 롤백합니다.
   - DB에 반영을 하지 않습니다.
   - test에만 commit을 하지않고 @service 등 이런 어노테이션에 붙으면 commit을 진행합니다.

> 기존에 있던 테스트 코드는 단위 테스트, DB까지 연결해서 테스트하는 것을 통합테스트라고 합니다.

> 모든 테스트는 단위 테스트로도 실행이 가능하도록 설계하는 것이 좋습니다.

<img src="../../iamges/spring_total_test.png" />

## 스프링 JdbcTemplate

```java
package hello.myspring.repository;

import hello.myspring.domain.Member;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;

import javax.sql.DataSource;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

public class JdbcTemplateMemberRepository implements MemberRepository {

    private final JdbcTemplate jdbcTemplate;

    public JdbcTemplateMemberRepository(DataSource dataSource){
        jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Override
    public Member save(Member member) {

        SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemplate);
        jdbcInsert.withTableName("member").usingGeneratedKeyColumns("id");

        Map<String, Object> parameters = new HashMap<>();
        parameters.put("name", member.getName());

        Number key = jdbcInsert.executeAndReturnKey(new MapSqlParameterSource(parameters));
        member.setId(key.longValue());

        return member;
    }

    @Override
    public Optional<Member> findById(Long id) {

        List<Member> result = jdbcTemplate.query("SELECT * FROM MEMBER WHERE id = ?", memberRowMapper(), id);

        return result.stream().findAny();
    }

    @Override
    public Optional<Member> findByName(String name) {
        List<Member> result = jdbcTemplate.query("SELECT * FROM MEMBER WHERE name = ?", memberRowMapper(), name);

        return result.stream().findAny();
    }

    @Override
    public List<Member> findAll() {
        return jdbcTemplate.query("SELECT * FROM MEMBER", memberRowMapper());
    }

    private RowMapper<Member> memberRowMapper(){
        return (rs, rowNum) -> {

            Member member = new Member();
            member.setId(rs.getLong("id"));
            member.setName(rs.getString("name"));

            return member;
        };
    }
}
```

`SpringConfig`

```java
@Bean
public MemberRepository memoryMemberRepository(){

    return new JdbcTemplateMemberRepository(this.dataSource);

}
```

> 환경 설정은 순수 Jdbc에서 했던 것과 동일합니다.

JdbcTemplate과 MyBatis 같은 라이브러리는 JDBC API에서 본 반복 코드를 대부분 제거해줍니다만 sql은 직접 작성해야합니다.

생성자가 한개인 경우 `@Autowired`를 생략 가능합니다.

<img src="../../iamges/Jdbc_template_test_success.png" />

굳이 스프링을 띄어서 직접 테스트하지 않고 위에서 만들어 놓은 테스트 코드로 확인하였습니다.

## JPA(자바 퍼시스턴스 API)

 - 반복 코드, SQL도 JPA에서는 작성할 필요가 없습니다.
 - SQL과 데이터 중심의 설계에서 객체 중심의 설계로 패러다임을 전환할 수 있습니다.
 - 개발생산성이 크게 높아집니다.

```gradle
dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	runtimeOnly 'com.h2database:h2'
	testImplementation('org.springframework.boot:spring-boot-starter-test') {
		exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
	}
}
```

라이브러리 추가를 진행합니다.

`application.properties`

```properties
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.driver-class-name=org.h2.Driver
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=none
```

`spring.jpa.show-sql` 만들어진 sql 표시 여부 옵션입니다.

`spring.jpa.hibernate.ddl-auto` 테이블 자동 생성 여부입니다. 현재 테이블이 작성되어 있고 만들어진 것을 사용하기 때문에 `none`으로 설정합니다.

> ORM : Object Relation Mapping

`JpaMemberRepository.java`

```java
package hello.myspring.repository;

import hello.myspring.domain.Member;

import javax.persistence.EntityManager;
import java.util.List;
import java.util.Optional;

public class JpaMemberRepository implements MemberRepository {

    private final EntityManager em;

    public JpaMemberRepository(EntityManager em) {
        this.em = em;
    }

    @Override
    public Member save(Member member) {
        em.persist(member);
        return member;
    }

    @Override
    public Optional<Member> findById(Long id) {
        Member member = em.find(Member.class, id);
        return Optional.ofNullable(member);
    }

    @Override
    public Optional<Member> findByName(String name) {

        return em.createQuery("SELECT m From Member AS m WHERE m.name = :name", Member.class)
                .setParameter("name", name)
                .getResultList()
                .stream()
                .findAny();

    }

    @Override
    public List<Member> findAll() {
        //객체를 기반으로 테이블을 조회합니다.
        return em.createQuery("SELECT m FROM Member AS m", Member.class).getResultList();
    }
}
```

`MemberService.java`

```java
package hello.myspring.service;

~
import org.springframework.transaction.annotation.Transactional;
~

@Transactional
public class MemberService {
    ~
}
```

Jpa가 동작하기 위해서는 Transctional상태여야 합니다.

`SpringConfig`

```java
@Configuration
public class SpringConfig {

    private EntityManager em;

    @Autowired
    public SpringConfig(EntityManager em){
        this.em = em;
    }

    @Bean
    public MemberService memberService(){
        return new MemberService(memoryMemberRepository());
    }

    @Bean
    public MemberRepository memoryMemberRepository(){
        return new JpaMemberRepository(this.em);
    }
}
```

`Member.java`

```java
package hello.myspring.domain;

import javax.persistence.*;

@Entity
public class Member {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)//DB가 자동으로 생성
    private Long id;
    private String name;

    ~
}
```

객체를 기반으로 테이블을 조회합니다.

<img src="../../iamges/jpa_test_success.png" />

테스트는 테스트 코드로 진행합니다.

## 스프링 데이터 JPA

 - CURD도 JPA가 제공합니다.
 - 핵심 비즈니스 로직을 개발하는데 집중할 수 있습니다.
 - 환경설정은 JPA와 동일합니다.

```java
package hello.myspring.repository;

import hello.myspring.domain.Member;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface SpringDataJpaMemberRepository extends JpaRepository<Member,Long>, MemberRepository {

    @Override
    Optional<Member> findByName(String name);
}
```

기본적인 CURD 및 ID를 이용한 조회, 페이지네이션 등 공통으로 사용할 수 있는 부분은 `JpaRepository`에 내장되어있습니다.

`findByName` : find By Name으로 구분하며 'name컬럼을 기준으로 조회를 하겠다' 라는 의미입니다.

그 외 `findByEmail`, `findByPhone`등이 있습니다.

```java
package hello.myspring;

import hello.myspring.repository.JdbcMemberRepository;
import hello.myspring.repository.JdbcTemplateMemberRepository;
import hello.myspring.repository.JpaMemberRepository;
import hello.myspring.repository.MemberRepository;
import hello.myspring.service.MemberService;
import net.bytebuddy.asm.Advice;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.persistence.EntityManager;
import javax.sql.DataSource;

@Configuration
public class SpringConfig {

    private final MemberRepository memberRepository;

    @Autowired
    public SpringConfig(MemberRepository memberRepository){
        this.memberRepository = memberRepository;
    }

    @Bean
    public MemberService memberService(){
        return new MemberService(memberRepository);
    }

}
```

<img src="../../iamges/spring_data_jpa.png" />

Jpa, 스프링 데이터 Jpa를 기본으로 사용하며 복잡한 동적쿼리는 Querydsl이라는 라이브러리를 이용하여 프로젝트를 진행합니다.

## 참고

https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/lecture/49593?tab=curriculum

https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/lecture/49594?tab=curriculum

https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/lecture/49595?tab=curriculum

https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/lecture/49597?tab=curriculum

https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/lecture/49598?tab=curriculum